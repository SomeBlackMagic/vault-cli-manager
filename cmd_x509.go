package main

import (
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"encoding/asn1"
	"math/big"
	"os"
	"time"

	fmt "github.com/jhunt/go-ansi"
	"github.com/SomeBlackMagic/vault-cli-manager/rc"
	"github.com/SomeBlackMagic/vault-cli-manager/vault"
)

func registerX509Commands(r *Runner, opt *Options) {
	r.Dispatch("x509", &Help{
		Summary: "Issue / Revoke X.509 Certificates and Certificate Authorities",
		Usage:   "safe x509 <command> [OPTIONS]",
		Type:    HiddenCommand,
		Description: `
x509 provides a handful of sub-commands for issuing, signing and revoking
SSL/TLS X.509 Certificates.  It does not utilize the pki Vault backend;
instead, all certificates and RSA keys are generated by the CLI itself,
and stored wherever you tell it to.

Here are the supported commands:

  @G{x509 issue} [OPTIONS] path/to/store/cert/in

    Issues a new X.509 certificate, which can be either self-signed,
    or signed by another CA certificate, elsewhere in the Vault.
    You can control the subject name, alternate names (DNS, email and
    IP addresses), Key Usage, Extended Key Usage, and TTL/expiry.


  @G{x509 revoke} [OPTIONS] path/to/cert

    Revokes an X.509 certificate that was issued by one of our CAs.


  @G{x509 crl} [OPTIONS] path/to/ca

    Manages a certificate revocation list, primarily to renew it
    (resigning it for freshness / liveness).


  @G{x509 validate} [OPTIONS] path/to/cert

    Validate a certificate in the Vault, checking to make sure that
    its private and public keys match, checking CA signatories,
    expiration, name applicability, etc.

  @G{x509 show} path/to/cert [path/to/other/cert ...]

    Print out a human-readable description of the certificate,
    including its subject name, issuer (CA), expiration and lifetime,
    and what domains, email addresses, and IP addresses it represents.

  @G{x509 reissue} [OPTIONS] path/to/certificate

    Regenerate the certificate and key at the given path.

  @G{x509 renew} [OPTIONS] path/to/certificate

    Renew the certificate at the given path
`,
	}, func(command string, args ...string) error {
		r.Help(os.Stdout, "x509")
		return nil
	})

	r.Dispatch("x509 validate", &Help{
		Summary: "Validate an X.509 Certificate / Private Key",
		Usage:   "safe x509 validate [OPTIONS} path/to/certificate/or/ca",
		Type:    NonDestructiveCommand,
		Description: `
Certificate validation can be checked in many ways, and this utility
provides most of them, including:

  - Certificate matches private key (default)
  - Certificate was signed by a given CA (--signed-by x)
  - Certificate is not revoked by its CA (--not-revoked)
  - Certificate is not expired (--not-expired)
  - Certificate is valid for a given name / IP / email address (--for)
  - RSA Private Key strength,in bits (--bits)

If any of the selected validations fails, safe will immediately exit
with a non-zero exit code to signal failure.  This can be used in scripts
to check certificates and alter behavior depending on their validity.

If the validations pass, safe will continue on to execute subsequent
sub-commands.

For revocation and expiry checks there are both positive validations (i.e.
this certificate *is* expired) and negative validations (not revoked).
This approach allows you to validate that the certificate you revoked is
actually revoked, while still validating that the certificate and key match,
CA signing constraints, etc.

The following options are recognized:

  -A, --ca            Check that this is a Certificate Authority, with the
                      ability to sign other certifictes.

  -i, --signed-by X   The path to the CA that signed this certificate.
                      safe will check that the CA is the one who signed
                      the certificate, and that the signature is valid.

  -R, --not-revoked   Verify that the certificate has not been revoked
                      by its signing CA.  This makes little sense with
                      self-signed certificates.  Requires the --signed-by
                      option to be specified.

  -r, --revoked       The opposite of --not-revoked; Verify that the CA
                      has revoked the certificate.  Requires --signed-by.

  -E, --not-expired   Check that the certificate is still valid, according
                      to its NotBefore / NotAfter values.

  -e, --expired       Check that the certificate is either not yet valid,
                      or is no longer valid.

  -n, --for N         Check a name / IP / email address against the CN
                      and subject alternate names (of the correct type),
                      to see if the certificate was issued for this name.
                      This can be specified multiple times, in which case
                      all checks must pass for safe to exit zero.

  -b, --bits N        Check that the RSA private key for this certificate
                      has the specified key size (in bits).  This can be
                      specified more than once, in which case any match
                      will pass validation.
`,
	}, func(command string, args ...string) error {
		if len(args) < 1 {
			r.ExitWithUsage("x509 validate")
		}
		if opt.X509.Validate.SignedBy == "" && opt.X509.Validate.Revoked {
			r.ExitWithUsage("x509 validate")
		}
		if opt.X509.Validate.SignedBy == "" && opt.X509.Validate.NotRevoked {
			r.ExitWithUsage("x509 validate")
		}

		rc.Apply(opt.UseTarget)
		v := connect(true)

		var ca *vault.X509
		if opt.X509.Validate.SignedBy != "" {
			s, err := v.Read(opt.X509.Validate.SignedBy)
			if err != nil {
				return err
			}
			ca, err = s.X509(true)
			if err != nil {
				return err
			}
		}

		for _, path := range args {
			s, err := v.Read(path)
			if err != nil {
				return err
			}
			cert, err := s.X509(true)
			if err != nil {
				return err
			}

			if err = cert.Validate(); err != nil {
				return fmt.Errorf("%s failed validation: %w", path, err)
			}

			if opt.X509.Validate.Bits != nil {
				if err = cert.CheckStrength(opt.X509.Validate.Bits...); err != nil {
					return fmt.Errorf("%s failed strength requirement: %w", path, err)
				}
			}

			if opt.X509.Validate.CA && !cert.IsCA() {
				return fmt.Errorf("%s is not a certificate authority", path)
			}

			if opt.X509.Validate.Revoked && !ca.HasRevoked(cert) {
				return fmt.Errorf("%s has not been revoked by %s", path, opt.X509.Validate.SignedBy)
			}
			if opt.X509.Validate.NotRevoked && ca.HasRevoked(cert) {
				return fmt.Errorf("%s has been revoked by %s", path, opt.X509.Validate.SignedBy)
			}

			if opt.X509.Validate.Expired && !cert.Expired() {
				return fmt.Errorf("%s has not yet expired", path)
			}
			if opt.X509.Validate.NotExpired && cert.Expired() {
				return fmt.Errorf("%s has expired", path)
			}

			if _, err = cert.ValidFor(opt.X509.Validate.Name...); err != nil {
				return err
			}

			if cert.IsCA() {
				if cert.Serial == nil {
					return fmt.Errorf("%s is missing its serial number tracker", path)
				}
				if cert.CRL == nil {
					return fmt.Errorf("%s is missing its certificate revocation list", path)
				}
			}

			if ca != nil { //If --signed-by was specified...
				err = cert.Certificate.CheckSignatureFrom(ca.Certificate)

				if err != nil {
					return fmt.Errorf("%s was not signed by %s", path, opt.X509.Validate.SignedBy)
				}
			}

			fmt.Printf("@G{%s} checks out.\n", path)
		}

		return nil
	})

	r.Dispatch("x509 issue", &Help{
		Summary: "Issue X.509 Certificates and Certificate Authorities",
		Usage:   "safe x509 issue [OPTIONS] --name cn.example.com path/to/certificate",
		Type:    DestructiveCommand,
		Description: `
Issue a new X.509 Certificate

The following options are recognized:

  -A, --ca            This certificate is a CA, and can
                      sign other certificates.

  -s, --subject       The subject name for this certificate.
                      i.e. /cn=www.example.com/c=us/st=ny...
                      If not specified, the first '--name'
                      will be used as a lone CN=...

  -i, --signed-by     Path in the Vault where the CA certificate
                      (and signing key) can be found.
                      Without this option, 'x509 issue' creates
                      self-signed certificates.

  -n, --name          Subject Alternate Name(s) for this
                      certificate.  These can be domain names,
                      IP addresses or email address -- safe will
                      figure out how to properly encode them.
                      Can (and probably should) be specified
                      more than once.

  -b, --bits N        RSA key strength, in bits.  The only valid
                      arguments are 1024 (highly discouraged),
                      2048 and 4096.  Defaults to 4096.

  -t, --ttl           How long the new certificate will be valid
                      for.  Specified in units h (hours), m (months)
                      d (days) or y (years).  1m = 30d and 1y = 365d
                      Defaults to 10y for CA certificates and 2y otherwise.

  -u, --key-usage     An x509 key usage or extended key usage. Can be specified
                      once for each desired usage. Valid key usage values are:
                      'digital_signature', 'non_repudiation', 'key_encipherment',
                      'data_encipherment', 'key_agreement', 'key_cert_sign',
                      'crl_sign', 'encipher_only', or 'decipher_only'. Valid
                      extended key usages are 'client_auth', 'server_auth', 'code_signing',
                      'email_protection', or 'timestamping'. The default extended
                      key usages are 'server_auth' and 'client_auth'. CA certs
                      will additionally have the default key usages of key_cert_sign
                      and crl_sign. Specifying any key usages manually will override
                      all of these defaults. To specify no key usages, add 'no' as the
                      only key usage.

  -l, --sig-algorithm The algorithm that the certificate will be signed
                      with. Valid values are md5-rsa, sha1-rsa, sha256-rsa
                      sha384-rsa, sha512-rsa, sha256-rsapss, sha384-rsapss,
                      sha512-rsapss, dsa-sha1, dsa-sha256, ecdsa-sha1,
                      ecdsa-sha256, ecdsa-sha384, and ecdsa-sha512. Defaults
                      to sha512-rsa.
`,
	}, func(command string, args ...string) error {
		rc.Apply(opt.UseTarget)

		var ca *vault.X509

		if len(args) != 1 || len(opt.X509.Issue.Name) == 0 {
			r.ExitWithUsage("x509 issue")
		}

		if opt.X509.Issue.Subject == "" {
			opt.X509.Issue.Subject = fmt.Sprintf("CN=%s", opt.X509.Issue.Name[0])
		}

		v := connect(true)
		if opt.SkipIfExists {
			if _, err := v.Read(args[0]); err == nil {
				if !opt.Quiet {
					fmt.Fprintf(os.Stderr, "@R{Cowardly refusing to create a new certificate in} @C{%s} @R{as it is already present in Vault}\n", args[0])
				}
				return nil
			} else if err != nil && !vault.IsNotFound(err) {
				return err
			}
		}

		if opt.X509.Issue.SignedBy != "" {
			secret, err := v.Read(opt.X509.Issue.SignedBy)
			if err != nil {
				return err
			}

			ca, err = secret.X509(true)
			if err != nil {
				return err
			}
		}

		if len(opt.X509.Issue.KeyUsage) == 0 {
			opt.X509.Issue.KeyUsage = append(opt.X509.Issue.KeyUsage, "server_auth", "client_auth")
			if opt.X509.Issue.CA {
				opt.X509.Issue.KeyUsage = append(opt.X509.Issue.KeyUsage, "key_cert_sign", "crl_sign")
			}
		}

		cert, err := vault.NewCertificate(opt.X509.Issue.Subject,
			uniq(opt.X509.Issue.Name), opt.X509.Issue.KeyUsage,
			opt.X509.Issue.SigAlgorithm, opt.X509.Issue.Bits)
		if err != nil {
			return err
		}

		if opt.X509.Issue.CA {
			cert.MakeCA()
		}

		if opt.X509.Issue.TTL == "" {
			opt.X509.Issue.TTL = "2y"
			if opt.X509.Issue.CA {
				opt.X509.Issue.TTL = "10y"
			}
		}
		ttl, err := duration(opt.X509.Issue.TTL)
		if err != nil {
			return err
		}
		if ca == nil {
			if err := cert.Sign(cert, ttl); err != nil {
				return err
			}
		} else {
			if err := ca.Sign(cert, ttl); err != nil {
				return err
			}

			err = ca.SaveTo(v, opt.X509.Issue.SignedBy, opt.SkipIfExists)
			if err != nil {
				return err
			}
		}

		err = cert.SaveTo(v, args[0], opt.SkipIfExists)
		if err != nil {
			return err
		}

		return nil
	})

	r.Dispatch("x509 reissue", &Help{
		Summary: "Reissue X.509 Certificates and Certificate Authorities",
		Usage:   "safe x509 reissue [OPTIONS] path/to/certificate",
		Type:    DestructiveCommand,
		Description: `
Reissues an X.509 Certificate with a new key.

The following options are recognized:

  -s, --subject       The subject name for this certificate.
                      i.e. /cn=www.example.com/c=us/st=ny...
                      Unlike in x509 issue, the subject will not automatically
                      take the first SAN - if you want to update it, you will
											need to specify this flag explicitly. Use caution when
                      changing the subject of a CA cert, as it will
                      invalidate the chain of trust between the CA and
                      certificates it has signed for many client implementations.

  -n, --name          Subject Alternate Name(s) for this
                      certificate.  These can be domain names,
                      IP addresses or email address -- safe will
                      figure out how to properly encode them.
                      Can (and probably should) be specified
											more than once. This flag will not append additional SANs,
											it will act as an exhaustive list in the same way that
                      it would for a new issue command.

  -b, --bits  N       RSA key strength, in bits.  The only valid
                      arguments are 1024 (highly discouraged),
                      2048 and 4096.  Defaults to the last value used
                      to (re)issue the certificate.

  -i, --signed-by     Path in the Vault where the CA certificate
                      (and signing key) can be found.  If this is not
                      provided, a sibling secret named 'ca' will used
                      if it exists. This should be the same CA that
                      originally signed the certificate, but does not
                      have to be.

  -t, --ttl           How long the new certificate will be valid
                      for.  Specified in units h (hours), m (months)
                      d (days) or y (years).  1m = 30d and 1y = 365d
                      Defaults to the last TTL used to issue or renew
                      the certificate.

  -u, --key-usage     An x509 key usage or extended key usage. Can be specified
                      once for each desired usage. Valid key usage values are:
                      'digital_signature', 'non_repudiation', 'key_encipherment',
                      'data_encipherment', 'key_agreement', 'key_cert_sign',
                      'crl_sign', 'encipher_only', or 'decipher_only'. Valid
                      extended key usages are 'client_auth', 'server_auth', 'code_signing',
                      'email_protection', or 'timestamping'. The default extended
                      key usages are 'server_auth' and 'client_auth'. CA certs
                      will additionally have the default key usages of key_cert_sign
                      and crl_sign. Specifying any key usages manually will override
                      all of these defaults. To specify no key usages, add 'no' as the
											only key usage.

  -l, --sig-algorithm The algorithm that the certificate will be signed
                      with. Valid values are md5-rsa, sha1-rsa, sha256-rsa
                      sha384-rsa, sha512-rsa, sha256-rsapss, sha384-rsapss,
                      sha512-rsapss, dsa-sha1, dsa-sha256, ecdsa-sha1,
                      ecdsa-sha256, ecdsa-sha384, and ecdsa-sha512. Defaults
                      to sha512-rsa.
`,
	}, func(command string, args ...string) error {
		rc.Apply(opt.UseTarget)

		if len(args) != 1 {
			r.ExitWithUsage("x509 reissue")
		}
		if opt.SkipIfExists {
			fmt.Fprintf(os.Stderr, "@R{!!} @C{--no-clobber} @R{is incompatible with} @C{safe x509 reissue}\n")
			r.ExitWithUsage("x509 reissue")
		}

		v := connect(true)

		/* find the Certificate that we want to renew */
		s, err := v.Read(args[0])
		if err != nil {
			return err
		}
		cert, err := s.X509(true)
		if err != nil {
			return err
		}

		if len(opt.X509.Reissue.Name) > 0 {
			ips, dns, email := vault.CategorizeSANs(uniq(opt.X509.Renew.Name))
			cert.Certificate.IPAddresses = ips
			cert.Certificate.DNSNames = dns
			cert.Certificate.EmailAddresses = email
		}

		if opt.X509.Reissue.Subject != "" {
			cert.Certificate.Subject, err = vault.ParseSubject(opt.X509.Reissue.Subject)
			if err != nil {
				return err
			}

			cert.Certificate.RawSubject, err = asn1.Marshal(cert.Certificate.Subject.ToRDNSequence())
			if err != nil {
				return err
			}
		}

		if len(opt.X509.Reissue.KeyUsage) > 0 {
			keyUsage, extKeyUsage, err := vault.HandleJointKeyUsages(opt.X509.Reissue.KeyUsage)
			if err != nil {
				return err
			}

			cert.Certificate.KeyUsage = keyUsage
			cert.Certificate.ExtKeyUsage = extKeyUsage
		}

		if opt.X509.Reissue.SigAlgorithm != "" {
			sigAlgo, err := vault.TranslateSignatureAlgorithm(opt.X509.Reissue.SigAlgorithm)
			if err != nil {
				return err
			}

			cert.Certificate.SignatureAlgorithm = sigAlgo
		}

		/* find the CA */
		ca, caPath, err := v.FindSigningCA(cert, args[0], opt.X509.Reissue.SignedBy)
		if err != nil {
			return err
		}

		// Get new expiry date
		var ttl time.Duration
		if opt.X509.Reissue.TTL == "" {
			ttl = cert.Certificate.NotAfter.Sub(cert.Certificate.NotBefore)
		} else {
			ttl, err = duration(opt.X509.Reissue.TTL)
			if err != nil {
				return err
			}
		}

		// Get signing key bit length
		if opt.X509.Reissue.Bits == 0 {
			opt.X509.Reissue.Bits = cert.PrivateKey.N.BitLen()
		}
		if opt.X509.Reissue.Bits != 1024 && opt.X509.Reissue.Bits != 2048 && opt.X509.Reissue.Bits != 4096 {
			return fmt.Errorf("Bits must be one of 1024, 2048 or 4096")
		}

		// Generate new key with same bit length.
		fmt.Printf("\nGenerating new %d-bit key...\n", opt.X509.Reissue.Bits)
		newKey, err := rsa.GenerateKey(rand.Reader, opt.X509.Reissue.Bits)
		if err != nil {
			return err
		}
		cert.PrivateKey = newKey
		err = ca.Sign(cert, ttl)
		if err != nil {
			return err
		}
		if caPath != args[0] {
			err = ca.SaveTo(v, caPath, false)
			if err != nil {
				return err
			}
		}

		err = cert.SaveTo(v, args[0], false)
		if err != nil {
			return err
		}

		fmt.Printf("Reissued x509 certificate at %s - expiry set to %s\n\n", args[0], cert.ExpiryString())

		return nil
	})

	r.Dispatch("x509 renew", &Help{
		Summary: "Renew X.509 Certificates and Certificate Authorities",
		Usage:   "safe x509 renew [OPTIONS] path/to/certificate",
		Type:    DestructiveCommand,
		Description: `
Renew an X.509 Certificate with existing key

The following options are recognized:
  -s, --subject       The subject name for this certificate.
                      i.e. /cn=www.example.com/c=us/st=ny...
                      Unlike in x509 issue, the subject will not automatically
                      take the first SAN - if you want to update it, you will
                      need to specify this flag explicitly. Use caution when
                      changing the subject of a CA cert, as it will
                      invalidate the chain of trust between the CA and
                      certificates it has signed for many client implementations.

  -n, --name          Subject Alternate Name(s) for this
                      certificate.  These can be domain names,
                      IP addresses or email address -- safe will
                      figure out how to properly encode them.
                      Can (and probably should) be specified
                      more than once. This flag will not append additional SANs,
                      it will act as an exhaustive list in the same way that
                      it would for a new issue command.

  -i, --signed-by   	Path in the Vault where the CA certificate
                      (and signing key) can be found.  If this is not
                      provided, a sibling secret named 'ca' will used
                      if it exists.  This should be the same CA that
                      originally signed the certificate, but does not
                      have to be.

  -t, --ttl           How long the new certificate will be valid
                      for.  Specified in units h (hours), m (months)
                      d (days) or y (years).  1m = 30d and 1y = 365d
                      Defaults to the last TTL used to issue or renew
                      the certificate.

  -u, --key-usage     An x509 key usage or extended key usage. Can be specified
                      once for each desired usage. Valid key usage values are:
                      'digital_signature', 'non_repudiation', 'key_encipherment',
                      'data_encipherment', 'key_agreement', 'key_cert_sign',
                      'crl_sign', 'encipher_only', or 'decipher_only'. Valid
                      extended key usages are 'client_auth', 'server_auth', 'code_signing',
                      'email_protection', or 'timestamping'. The default extended
                      key usages are 'server_auth' and 'client_auth'. CA certs
                      will additionally have the default key usages of key_cert_sign
                      and crl_sign. Specifying any key usages manually will override
                      all of these defaults. To specify no key usages, add 'no' as the
											only key usage.

  -l, --sig-algorithm The algorithm that the certificate will be signed
                      with. Valid values are md5-rsa, sha1-rsa, sha256-rsa
                      sha384-rsa, sha512-rsa, sha256-rsapss, sha384-rsapss,
                      sha512-rsapss, dsa-sha1, dsa-sha256, ecdsa-sha1,
                      ecdsa-sha256, ecdsa-sha384, and ecdsa-sha512. Defaults
                      to sha512-rsa.
`,
	}, func(command string, args ...string) error {
		rc.Apply(opt.UseTarget)

		if len(args) != 1 {
			r.ExitWithUsage("x509 renew")
		}
		if opt.SkipIfExists {
			fmt.Fprintf(os.Stderr, "@R{!!} @C{--no-clobber} @R{is incompatible with} @C{safe x509 renew}\n")
			r.ExitWithUsage("x509 renew")
		}

		v := connect(true)

		/* find the Certificate that we want to renew */
		s, err := v.Read(args[0])
		if err != nil {
			return err
		}
		cert, err := s.X509(true)
		if err != nil {
			return err
		}

		if len(opt.X509.Renew.Name) > 0 {
			ips, dns, email := vault.CategorizeSANs(uniq(opt.X509.Renew.Name))
			cert.Certificate.IPAddresses = ips
			cert.Certificate.DNSNames = dns
			cert.Certificate.EmailAddresses = email
		}

		if opt.X509.Renew.Subject != "" {
			cert.Certificate.Subject, err = vault.ParseSubject(opt.X509.Renew.Subject)
			if err != nil {
				return err
			}

			cert.Certificate.RawSubject, err = asn1.Marshal(cert.Certificate.Subject.ToRDNSequence())
			if err != nil {
				return err
			}
		}

		if len(opt.X509.Renew.KeyUsage) > 0 {
			keyUsage, extKeyUsage, err := vault.HandleJointKeyUsages(opt.X509.Renew.KeyUsage)
			if err != nil {
				return err
			}

			cert.Certificate.KeyUsage = keyUsage
			cert.Certificate.ExtKeyUsage = extKeyUsage
		}

		if opt.X509.Renew.SigAlgorithm != "" {
			sigAlgo, err := vault.TranslateSignatureAlgorithm(opt.X509.Renew.SigAlgorithm)
			if err != nil {
				return err
			}

			cert.Certificate.SignatureAlgorithm = sigAlgo
		}

		/* find the CA */
		ca, caPath, err := v.FindSigningCA(cert, args[0], opt.X509.Renew.SignedBy)
		if err != nil {
			return err
		}

		// Get new expiry date
		var ttl time.Duration
		if opt.X509.Renew.TTL == "" {
			ttl = cert.Certificate.NotAfter.Sub(cert.Certificate.NotBefore)
		} else {
			ttl, err = duration(opt.X509.Renew.TTL)
			if err != nil {
				return err
			}
		}

		err = ca.Sign(cert, ttl)
		if err != nil {
			return err
		}
		if caPath != args[0] {
			err = ca.SaveTo(v, caPath, false)
			if err != nil {
				return err
			}
		}

		err = cert.SaveTo(v, args[0], false)
		if err != nil {
			return err
		}

		fmt.Printf("\nRenewed x509 certificate at %s - expiry set to %s\n\n", args[0], cert.ExpiryString())
		return nil
	})

	r.Dispatch("x509 revoke", &Help{
		Summary: "Revoke X.509 Certificates and Certificate Authorities",
		Usage:   "safe x509 revoke [OPTIONS] path/to/certificate",
		Type:    DestructiveCommand,
		Description: `
Revoke an X.509 Certificate via its Certificate Authority

The following options are recognized:

  -i, --signed-by   Path in the Vault where the CA certificate that
                    signed the certificate to revoke resides.
`,
	}, func(command string, args ...string) error {
		if opt.X509.Revoke.SignedBy == "" || len(args) != 1 {
			r.ExitWithUsage("x509 revoke")
		}

		rc.Apply(opt.UseTarget)
		v := connect(true)

		/* find the CA */
		s, err := v.Read(opt.X509.Revoke.SignedBy)
		if err != nil {
			return err
		}
		ca, err := s.X509(true)
		if err != nil {
			return err
		}

		/* find the Certificate */
		s, err = v.Read(args[0])
		if err != nil {
			return err
		}
		cert, err := s.X509(true)
		if err != nil {
			return err
		}

		/* revoke the Certificate */
		/* FIXME make sure the CA signed this cert */
		ca.Revoke(cert)
		s, err = ca.Secret(false) // SkipIfExists doesnt make sense in the context of revoke
		if err != nil {
			return err
		}

		err = v.Write(opt.X509.Revoke.SignedBy, s)
		if err != nil {
			return err
		}

		return nil
	})

	r.Dispatch("x509 show", &Help{
		Summary: "Show the details of an X.509 Certificate",
		Usage:   "safe x509 show path [path ...]",
		Type:    NonDestructiveCommand,
		Description: `
When dealing with lots of different X.509 Certificates, it is important
to be able to identify what lives at each path in the vault.  This command
prints out information about a certificate, including:

  - Who issued it?
  - Is it a Certificate Authority?
  - What names / IPs is it valid for?
  - When does it expire?

`,
	}, func(command string, args ...string) error {
		if len(args) == 0 {
			r.ExitWithUsage("x509 show")
		}

		rc.Apply(opt.UseTarget)
		v := connect(true)

		for _, path := range args {
			s, err := v.Read(args[0])
			if err != nil {
				return err
			}

			fmt.Printf("%s:\n", path)
			cert, err := s.X509(false)
			if err != nil {
				fmt.Printf("  !! %s\n\n", err)
				continue
			}

			fmt.Printf("  @G{%s}\n\n", cert.Subject())
			if cert.Subject() != cert.Issuer() {
				fmt.Printf("  issued by: @C{%s}\n", cert.Issuer())
				for i := range cert.Intermediaries {
					fmt.Printf("        via: @C{%s}\n", cert.IntermediarySubject(i))
				}
			} else {
				fmt.Printf("  @C{self-signed}\n")
			}

			toStart := cert.Certificate.NotBefore.Sub(time.Now())
			toEnd := cert.Certificate.NotAfter.Sub(time.Now())

			days := int(toStart.Hours() / 24)
			if days == 1 {
				fmt.Printf("  @Y{not valid for another day}\n")
			} else if days > 1 {
				fmt.Printf("  @Y{not valid for another %d days}\n", days)
			}

			days = int(toEnd.Hours() / 24)
			if days < -1 {
				fmt.Printf("  @R{EXPIRED %d days ago}\n", -1*days)
			} else if days < 0 {
				fmt.Printf("  @R{EXPIRED a day ago}\n")
			} else if days < 1 {
				fmt.Printf("  @R{EXPIRED}\n")
			} else if days == 1 {
				fmt.Printf("  @Y{expires in a day}\n")
			} else if days < 30 {
				fmt.Printf("  @Y{expires in %d days}\n", days)
			} else {
				fmt.Printf("  expires in @G{%d days}\n", days)
			}
			fmt.Printf("  valid from @C{%s} - @C{%s}", cert.Certificate.NotBefore.Format("Jan 2 2006"), cert.Certificate.NotAfter.Format("Jan 2 2006"))

			life := int(cert.Certificate.NotAfter.Sub(cert.Certificate.NotBefore).Hours())
			if life < 360*24 {
				fmt.Printf(" (@M{~%d days})\n", life/24)
			} else {
				fmt.Printf(" (@M{~%d years})\n", life/365/24)
			}
			fmt.Printf("\n")

			n := 0
			fmt.Printf("  for the following purposes:\n")
			if cert.KeyUsage&x509.KeyUsageDigitalSignature != 0 {
				n++
				fmt.Printf("    - @C{digital-signature}  can be used to verify digital signatures.\n")
			}
			if cert.KeyUsage&x509.KeyUsageContentCommitment != 0 {
				n++
				fmt.Printf("    - @C{non-repudiation}    can be used for non-repudiation / content commitment.\n")
			}
			if cert.KeyUsage&x509.KeyUsageKeyEncipherment != 0 {
				n++
				fmt.Printf("    - @C{key-encipherment}   can be used encrypt other keys, for transport.\n")
			}
			if cert.KeyUsage&x509.KeyUsageDataEncipherment != 0 {
				n++
				fmt.Printf("    - @C{data-encipherment}  can be used to encrypt user data directly.\n")
			}
			if cert.KeyUsage&x509.KeyUsageKeyAgreement != 0 {
				n++
				fmt.Printf("    - @C{key-agreement}      can be used in key exchange, a la Diffie-Hellman key exchange.\n")
			}
			if cert.KeyUsage&x509.KeyUsageCertSign != 0 {
				n++
				fmt.Printf("    - @C{key-cert-sign}      can be used to verify digital signatures on public key certificates.\n")
			}
			if cert.KeyUsage&x509.KeyUsageCRLSign != 0 {
				n++
				fmt.Printf("    - @C{crl-sign}           can be used to verify digital signatures on certificate revocation lists.\n")
			}
			if cert.KeyUsage&x509.KeyUsageEncipherOnly != 0 {
				n++
				if cert.KeyUsage&x509.KeyUsageKeyAgreement != 0 {
					fmt.Printf("    - @C{encipher-only}      can only be used to encrypt data in a key exchange.\n")
				} else {
					fmt.Printf("    - @C{encipher-only}      this key-usage is undefined if key-agreement is not set (which it isn't).\n")
				}
			}
			if cert.KeyUsage&x509.KeyUsageDecipherOnly != 0 {
				n++
				if cert.KeyUsage&x509.KeyUsageKeyAgreement != 0 {
					fmt.Printf("    - @C{decipher-only}      can only be used to decrypt data in a key exchange.\n")
				} else {
					fmt.Printf("    - @C{decipher-only}      this key-usage is undefined if key-agreement is not set (which it isn't).\n")
				}
			}
			for _, ku := range cert.ExtKeyUsage {
				n++
				switch ku {
				default:
					n--
				case x509.ExtKeyUsageClientAuth:
					fmt.Printf("    - @C{client-auth}*       can be used by a TLS client for authentication.\n")
				case x509.ExtKeyUsageServerAuth:
					fmt.Printf("    - @C{server-auth}*       can be used by a TLS server for authentication.\n")
				case x509.ExtKeyUsageCodeSigning:
					fmt.Printf("    - @C{code-signing}*      can be used to sign software packages to prove source.\n")
				case x509.ExtKeyUsageEmailProtection:
					fmt.Printf("    - @C{email-protection}*  can be used to protect email (signing, encryption, and key exchange).\n")
				case x509.ExtKeyUsageTimeStamping:
					fmt.Printf("    - @C{timestamping}*      can be used to generate trusted timestamps.\n")
				}
			}
			if n == 0 {
				fmt.Printf("    (no special key usage constraints present)\n")
			}
			fmt.Printf("\n")

			fmt.Printf("  signed with the algorithm ")
			sigView := map[x509.SignatureAlgorithm]string{
				x509.UnknownSignatureAlgorithm: "Unknown",
				x509.MD2WithRSA:                "MD2 With RSA",
				x509.MD5WithRSA:                "MD5 With RSA",
				x509.SHA1WithRSA:               "SHA1 With RSA",
				x509.SHA256WithRSA:             "SHA256 With RSA",
				x509.SHA384WithRSA:             "SHA384 With RSA",
				x509.SHA512WithRSA:             "SHA512 With RSA",
				x509.DSAWithSHA1:               "DSA With SHA1",
				x509.DSAWithSHA256:             "DSA With SHA256",
				x509.ECDSAWithSHA1:             "ECDSA With SHA1",
				x509.ECDSAWithSHA256:           "ECDSA With SHA256",
				x509.ECDSAWithSHA384:           "ECDSA With SHA384",
				x509.ECDSAWithSHA512:           "ECDSA With SHA512",
				x509.SHA256WithRSAPSS:          "SHA256 With RSAPSS",
				x509.SHA384WithRSAPSS:          "SHA384 With RSAPSS",
				x509.SHA512WithRSAPSS:          "SHA512 With RSAPSS",
			}
			sigAlgo := sigView[cert.Certificate.SignatureAlgorithm]
			fmt.Printf("@G{%s}\n", sigAlgo)
			fmt.Printf("\n")

			fmt.Printf("  for the following names:\n")
			for _, s := range cert.Certificate.DNSNames {
				fmt.Printf("    - @G{%s} (DNS)\n", s)
			}
			for _, s := range cert.Certificate.EmailAddresses {
				fmt.Printf("    - @G{%s} (email)\n", s)
			}
			for _, s := range cert.Certificate.IPAddresses {
				fmt.Printf("    - @G{%s} (IP)\n", s)
			}
			fmt.Printf("\n")

			serialString := fmt.Sprintf("@M{%[1]d} (@M{%#[1]x})", cert.Certificate.SerialNumber)
			if cert.Certificate.SerialNumber.Cmp(big.NewInt(1000)) == 1 {
				serialString = fmt.Sprintf("@M{%s}", cert.FormatSerial())
			}
			fmt.Printf("  serial: %s\n", serialString)
			fmt.Printf("  ")
			if cert.IsCA() {
				fmt.Printf("@G{is}")
			} else {
				fmt.Printf("@Y{is not}")
			}
			fmt.Printf(" a CA\n")
			fmt.Printf("\n")
		}

		return nil
	})

	r.Dispatch("x509 crl", &Help{
		Summary: "Manage a X.509 Certificate Authority Revocation List",
		Usage:   "safe x509 crl --renew path",
		Type:    DestructiveCommand,
		Description: `
Each X.509 Certificate Authority (especially those generated by
'safe issue --ca') carries with a list of certificates it has revoked,
by certificate serial number.  This command lets you manage that CRL.

Currently, only the --renew option is supported, and it is required:

  --renew           Sign and update the validity dates of the CRL,
                    without modifying the list of revoked certificates.
`,
	}, func(command string, args ...string) error {
		if !opt.X509.CRL.Renew || len(args) != 1 {
			r.ExitWithUsage("x509 crl")
		}

		rc.Apply(opt.UseTarget)
		v := connect(true)

		s, err := v.Read(args[0])
		if err != nil {
			return err
		}
		ca, err := s.X509(true)
		if err != nil {
			return err
		}

		if !ca.IsCA() {
			return fmt.Errorf("%s is not a certificate authority", args[0])
		}

		/* simply re-saving the CA X509 object regens the CRL */
		s, err = ca.Secret(false) // SkipIfExists doesn't make sense in the context of crl regeneration
		if err != nil {
			return err
		}
		err = v.Write(args[0], s)
		if err != nil {
			return err
		}

		return nil
	})
}
